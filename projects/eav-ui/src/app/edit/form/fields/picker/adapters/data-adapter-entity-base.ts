import { HttpErrorResponse } from "@angular/common/http";
import { EditForm } from "projects/eav-ui/src/app/shared/models/edit-form.model";
import { DeleteEntityProps } from "../models/picker.models";
import { DataAdapterBase } from "./data-adapter-base";
import { FieldMask } from "../../../../shared/helpers";
import { BehaviorSubject, Observable } from "rxjs";
import { MatSnackBar } from "@angular/material/snack-bar";
import { TranslateService } from "@ngx-translate/core";
import { PickerItem } from "projects/edit-types";
import { EntityService, FormConfigService, EditRoutingService } from "../../../../shared/services";
import { EavLogger } from 'projects/eav-ui/src/app/shared/logging/eav-logger';
import { StateAdapter } from './state-adapter';
import { DataSourceBase } from '../data-sources/data-source-base';
import { DataSourceEmpty } from '../data-sources/data-source-empty';
import { PickerFeatures } from '../picker-features.model';
import { Injector, computed, effect, inject, runInInjectionContext, signal, untracked } from '@angular/core';
import { SignalHelpers } from 'projects/eav-ui/src/app/shared/helpers/signal.helpers';
import { RxHelpers } from 'projects/eav-ui/src/app/shared/rxJs/rx.helpers';
import { EntityFormStateService } from '../../../entity-form-state.service';
import { FieldState } from '../../../builder/fields-builder/field-state';


export abstract class DataAdapterEntityBase extends DataAdapterBase {

  /** Content Type Mask - but will be generated by an effect later on */
  private contentTypeMaskLazy = signal<FieldMask>(null);
  protected contentType = computed(() => this.contentTypeMaskLazy()?.signal() ?? '', SignalHelpers.stringEquals);
  private createEntityTypes = signal<string>('', SignalHelpers.stringEquals);

  /**
   * The features depend on contentType names being available to support create
   */
  public features = computed<Partial<PickerFeatures>>(
    () => {
      // if we don't know the content-type, we can't create new entities
      const disableCreate = !this.contentType() && !this.createEntityTypes();
      return { create: !disableCreate } satisfies Partial<PickerFeatures>;
    },
    { equal: RxHelpers.objectsEqual }
  );

  protected deletedItemGuids$ = new BehaviorSubject<string[]>([]);

  protected dataSource: DataSourceBase;

  private entityService = inject(EntityService);
  protected formConfig = inject(FormConfigService);
  private editRoutingService = inject(EditRoutingService);
  protected translate = inject(TranslateService);
  private snackBar = inject(MatSnackBar);
  private dataSourceEmpty = inject(DataSourceEmpty);
  protected injector = inject(Injector);

  protected fieldState = inject(FieldState);
  protected group = inject(EntityFormStateService).formGroup();

  constructor(
    private dataSourceEntityOrQuery: DataSourceBase,
    logSpecs: EavLogger,
  ) {
    super(logSpecs);
    this.log.a('constructor');
  }

  public linkLog(log: EavLogger): this {
    if (!this.log.enabled)
      this.log.inherit(log);
    return this;
  };

  public setupFromComponent(state: StateAdapter, useEmpty: boolean): this  {
    this.log.a('setupFromComponent');

    const settings = this.fieldState.settings
    this.dataSource = useEmpty
      ? this.dataSourceEmpty.preSetup("Error: configuration missing").setup(settings)
      : this.dataSourceEntityOrQuery.setup(settings);

    super.setup(state.doAfterDelete);
    return this;
  }

  init(callerName: string): void {
    super.init(callerName);
    // Update/Build Content-Type Mask which is used for loading the data/new etc.

    const settings = this.fieldState.settings
    const typeMaskFromSettings = computed(() => settings().EntityType, SignalHelpers.stringEquals);
    const createTypesFromSettings = computed(() => settings().CreateTypes, SignalHelpers.stringEquals);

    // let typeMaskBefore: string = null;
    runInInjectionContext(this.injector, () => {

      // Run Effect when the content type changes
      effect(() => {
        this.createEntityTypes.set(createTypesFromSettings());
      }, { allowSignalWrites: true /* necessary because we're setting another signal */ });

      // Run effect to ensure we have a mask for the content type
      let count = 100;
      effect(() => {
        count--;
        if (count < 0) {
          console.error('Error: Could not create contentTypeMask in EntitySourceAdapter');
          return;
        }
        const typeMask = typeMaskFromSettings();
        console.log('typeMask', typeMask); // should only fire on changes
        this.log.a('init in EntitySourceAdapter, about to create contentTypeMask');

        // Don't track these accesses as dependencies!
        untracked(() => {
          this.contentTypeMaskLazy()?.destroy();

          // In this new signals are created, which would be tracked as dependencies of this signal
          // if not inside untracked.
          const newMask = FieldMask.createTransient(this.injector)
            .init('PickerSource-EntityType', typeMask, true)
            .logChanges();

          this.contentTypeMaskLazy.set(newMask);
        });
      }, { allowSignalWrites: true /* necessary because the mask has an observable which is set */ });


    });

    // this.subscriptions.add(
    //   this.settings$.pipe(
    //     map(settings => ({
    //       contentType: settings.EntityType,
    //       createEntityTypes: settings.CreateTypes,
    //     })),
    //     distinctUntilChanged(RxHelpers.objectsEqual),
    //   ).subscribe(specs => {
    //     this.createEntityTypesOld = specs.createEntityTypes;
    //     this.log.a('about to create contentTypeMask');
    //     this.contentTypeMaskOld?.destroy();
    //     this.contentTypeMaskOld = new FieldMask(
    //       specs.contentType,
    //       this.group.controls,
    //       () => { /* callback not used, but expected as parameter, otherwise watcher fails */ },
    //       null,
    //       this.formConfig.config,
    //       this.config,
    //       'PickerSource-EntityType',
    //       true, // override log
    //     );

    //     // watch for changes
    //     this.subscriptions.add(
    //       this.contentTypeMaskOld.value$.subscribe(contentType => {
    //         // this.contentTypeOld = contentType;
    //         this.optionsOrHints$.next(null);
    //         this.updateAddNew();
    //         this.log.a(`contentTypeMask.value$:'${contentType}'`);
    //       })
    //     );
    //     this.optionsOrHints$.next(null);
    //     this.updateAddNew();
    //   })
    // );
  }


  getDataFromSource(): Observable<PickerItem[]> {
    return this.dataSource.data$;
  }

  initPrefetch(prefetchGuids: string[]): void {
    this.dataSource.initPrefetch(prefetchGuids);
  }

  forceReloadData(missingData: string[]): void {
    this.dataSource.addToRefresh(missingData);
  }


  // private updateAddNew(): void {
  //   this.log.a('updateAddNew');
  //   // const contentTypeName = this.contentTypeMask.resolve();
  //   const disableCreate = !this.contentType() && !this.createEntityTypes();
  //   this.features.update(p => ({ ...p, create: !disableCreate } satisfies Partial<PickerFeatures>));
  // }

  // Note: 2dm 2023-01-24 added entityId as parameter #maybeRemoveGuidOnEditEntity
  // not even sure if the guid would still be needed, as I assume the entityId
  // should always be available.
  // Must test all use cases and then probably simplify again.
  editItem(editParams: { entityGuid: string, entityId: number }, entityType: string): void {
    this.log.a('editItem', [editParams]);
    if (editParams)
      this.editEntityGuid$.next(editParams.entityGuid);
    let form: EditForm;
    if (editParams?.entityGuid == null) {
      const contentTypeName = entityType ?? this.contentType();
      const prefill = this.getPrefill();
      form = {
        items: [{ ContentTypeName: contentTypeName, Prefill: prefill }],
      };
    } else {
      const entity = this.optionsOrHints$.value.find(item => item.value === editParams.entityGuid);
      // if (entity != null) {
      //   form = {
      //     items: [{ EntityId: entity.id }],
      //   };
      // } else {
      //   form = {
      //     items: [{ EntityId: editParams.entityId }],
      //   };
      // }
      form = {
        items: [{ EntityId: entity?.id ?? editParams.entityId }],
      };
    }
    const config = this.fieldState.config;
    this.editRoutingService.open(config.index, config.entityGuid, form);
  }

  deleteItem(props: DeleteEntityProps): void {
    this.log.a('deleteItem', [props]);
    const entity = this.optionsOrHints$.value.find(item => item.value === props.entityGuid);
    const id = entity.id;
    const title = entity.label;
    const contentType = this.contentType();
    const config = this.fieldState.config;
    const parentId = config.entityId;
    const parentField = config.fieldName;

    const confirmed = confirm(this.translate.instant('Data.Delete.Question', { title, id }));
    if (!confirmed) { return; }

    this.snackBar.open(this.translate.instant('Message.Deleting'));
    this.entityService.delete(contentType, id, false, parentId, parentField).subscribe({
      next: () => {
        this.snackBar.open(this.translate.instant('Message.Deleted'), null, { duration: 2000 });
        this.deleteCallback(props); // removes value from selected values
        this.deletedItemGuids$.next([...this.deletedItemGuids$.value, props.entityGuid]);
      },
      error: (error1: HttpErrorResponse) => {
        this.snackBar.dismiss();
        if (!confirm(this.translate.instant('Data.Delete.Question', { title, id }))) { return; }
        this.snackBar.open(this.translate.instant('Message.Deleting'));
        this.entityService.delete(contentType, id, true, parentId, parentField).subscribe({
          next: () => {
            this.snackBar.open(this.translate.instant('Message.Deleted'), null, { duration: 2000 });
            this.deleteCallback(props); // removes value from selected values
            this.deletedItemGuids$.next([...this.deletedItemGuids$.value, props.entityGuid]);
          },
          error: (error2: HttpErrorResponse) => {
            this.snackBar.open(this.translate.instant('Message.DeleteError'), null, { duration: 2000 });
          }
        });
      }
    });
  }

  /**
   * Will create a prefill object (if configured) which is based on a field-mask.
   * This allows create-entity to use add prefills.
   * ATM just normal values (text/number) or placeholders like [Title] work.
   * In future we may add more features like dates etc.
   * new 11.11.03
   */
  private getPrefill(): Record<string, string> {
    this.log.a('getPrefill');
    // still very experimental, and to avoid errors try to catch any mistakes
    try {
      const prefillRaw = this.fieldState.settings().Prefill;
      const prefillMask = FieldMask.createTransient(this.injector)
        .init('Prefill', prefillRaw, false);
      const prefill = prefillMask.resolve();
      prefillMask.destroy();
      if (!prefill || !prefill.trim()) { return null; }
      const result: Record<string, string> = {};
      prefill.split('\n').forEach(line => {
        const parts = line.split('=');
        if (parts.length === 2 && parts[0] && parts[1]) {
          result[parts[0]] = parts[1];
        }
      });
      return result;
    } catch {
      console.error('Error in getting Prefill for new entity. Will skip prefill.');
      return null;
    }
  }
}